DONE 
4.1 Your task is to create a custom argument matcher that matches a Person object based on a provided age range.
The matcher should return true if the age of the Person object is within the specified range, inclusive.

Define a class Person with at least one field: int age.

Implement a custom argument matcher that matches Person objects within a given age range.

Use the matcher in a test case to verify that a mock method is called with a Person of the correct age.



4.2 You are testing a UserService that relies on a UserRepository. 

You need to ensure that the mock UserRepository:

Is serializable.

Has a default answer that logs unstubbed method invocations.

Captures method invocation details for debugging purposes.



Create a mock UserRepository with the following requirements:

Implement the repository as a serializable mock.

Ensure that any unstubbed call is answered by logging the invocation to the console.

Attach an invocation listener that records each method call (method name and arguments) to a list.

Write at least two test cases that use this mock:

The first test should invoke a stubbed method and assert the expected behavior.

The second test should invoke an unstubbed method and verify that the default answer is applied and the invocation details are recorded.

(Подсказка: дефолтна відповідь може бути тільки одна, і якщо тобі треба більше ніж одна дефолтна, то можливо слід розглянути інші інструменти, які краще для цього підходять - Argument Matchers.

        UserRepository userRepositoryMock = mock(UserRepository.class,
                withSettings()
                        .defaultAnswer(invocation -> {
                            if (invocation.getMethod().getReturnType().equals(int.class)) {
                                return -1;
                            }
                            if (invocation.getMethod().getReturnType().equals(String.class)) {
                                return "Default answer";
                            }
                            if (invocation.getMethod().getReturnType().equals(User.class)) {
                                return new User(1, "john", "qwerty");
                            }

                            return "Default answer";
                        }));


)



4.3 You are provided with a PaymentProcessor class that interacts with a BankService. 
Your task is to write a unit test for the PaymentProcessor.processPayment() method to ensure that 
it correctly handles successful payment processing. You need to spy on the BankService to prevent 
the actual bank communication and verify that processPayment() behaves as expected when the bank 
service indicates a successful payment.


Setup:

BankService class with a method boolean performPayment(AccountDetails details, BigDecimal amount).

PaymentProcessor class with a method processPayment(AccountDetails details, BigDecimal amount) 
that calls BankService.performPayment().


Task:


Create a test class named PaymentProcessorTest.

Write a test method named testProcessPaymentSuccess.

Within the test method, create a spy of BankService.

Stub the performPayment method to return true to simulate a successful payment scenario.

Call processPayment from PaymentProcessor.

Verify that processPayment was called exactly once and that it processed the payment successfully.

